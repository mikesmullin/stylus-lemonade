// Generated by CoffeeScript 1.4.0

/**
 * Lemonade: Automatically Generate CSS Sprites from Images with Stylus
 * a Node.js + Stylus implementation
 *
 * Copyright 2012 Smullin Design and other contributors
 * http://smullindesign.com/
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/


(function() {
  var Image, Lemonade, Sprite, async, fs, gd, instance,
    __hasProp = {}.hasOwnProperty;

  gd = require('node-gd');

  async = require('mini-async');

  fs = require('fs');

  instance = void 0;

  Lemonade = (function() {

    function Lemonade(options) {
      this.options = options;
    }

    Lemonade.prototype.reset = function() {
      var _base, _base1, _base2, _ref, _ref1, _ref2, _ref3;
      if ((_ref = this.options) == null) {
        this.options = {};
      }
      if ((_ref1 = (_base = this.options).image_path) == null) {
        _base.image_path = './';
      }
      if ((_ref2 = (_base1 = this.options).sprite_path) == null) {
        _base1.sprite_path = './';
      }
      if ((_ref3 = (_base2 = this.options).sprite_url) == null) {
        _base2.sprite_url = './';
      }
      this.sprites = {};
      return this.series = [];
    };

    Lemonade.prototype.infect = function(stylus_instance) {
      var _this = this;
      this.reset();
      /**
       * sprite-map(sprite, options)
       * @param {String} sprite_filename
       *   name of sprite file to generate without .png extension
       *   default is 'sprite'
       * @param {String} options
       *   (optional) css-like key: value; string of options for sprite engine
       * @return {String}
      */

      stylus_instance.define('sprite-map', function(sprite, options) {
        if (sprite == null) {
          sprite = {
            string: 'sprite'
          };
        }
        if (options == null) {
          options = {
            string: ''
          };
        }
        return "sprite:" + sprite.string + ";" + options.string;
      });
      /**
       * sprite-url(map)
       * @param {String} map
       *   string returned by sprite-map()
       * @return {String}
       *   url to the sprite map's corresponding sprite file; for browsers
      */

      stylus_instance.define('sprite-url', function(map) {
        return _this._generate_placeholder('URL', map.string);
      });
      /**
       * sprite-position(map, png)
       * the only function that actually triggers sprite generation
       * @param {String} map
       *   string returned by sprite-map()
       * @param {String} png
       *   image filename without .png extension
       * @return {String}
       *   x, y coordinates of original image within compiled sprite
      */

      stylus_instance.define('sprite-position', function(map, png) {
        return _this._generate_placeholder('POSITION', map.string, png.string);
      });
      /**
       * sprite(map, png)
       * the only function that actually triggers sprite generation
       * @param {String} map
       *   string returned by sprite-map()
       * @param {String} png
       *   image filename without .png extension
       * @return {String}
       *   sprite image url() and x, y coordinates of original image
      */

      stylus_instance.define('sprite', function(map, png) {
        return _this._generate_placeholder('URL_AND_IMAGE_POSITION', map.string, png.string);
      });
      /**
       * sprite-width(map)
       * @param {String} map
       *   string returned by sprite-map()
       * @param {String} png
       *   image filename without .png extension
       * @return {Integer}
       *   width in pixels
      */

      stylus_instance.define('sprite-width', function(map, png) {
        return _this._generate_placeholder('WIDTH', map.string, png.string);
      });
      /**
       * sprite-height(map)
       * @param {String} map
       *   string returned by sprite-map()
       * @param {String} png
       *   image filename without .png extension
       * @return {Integer}
       *   height in pixels
      */

      stylus_instance.define('sprite-height', function(map, png) {
        return _this._generate_placeholder('HEIGHT', map.string, png.string);
      });
      stylus_instance.on('end', function(css, callback) {
        async.series(_this.series, function(next, err) {
          var series, sprite, sprite_key, _fn, _ref;
          if (err) {
            return callback(err, css);
          }
          css = css.replace(/["']SPRITE_(.+?)_PLACEHOLDER\((.+?), (.*?)\)["']/g, function(match, key, sprite_key, png) {
            var image, sprite;
            sprite = _this.sprites[sprite_key];
            image = sprite.images[png];
            switch (key) {
              case 'POSITION':
                return image.coords();
              case 'URL':
                return sprite.digest_url();
              case 'URL_AND_IMAGE_POSITION':
                return "url(" + (sprite.digest_url()) + ") " + (image.coords());
              case 'WIDTH':
                return image.px(image.width);
              case 'HEIGHT':
                return image.px(image.height);
            }
          });
          series = [];
          _ref = _this.sprites;
          _fn = function(sprite) {
            return series.push(function(next) {
              return sprite.render(next);
            });
          };
          for (sprite_key in _ref) {
            if (!__hasProp.call(_ref, sprite_key)) continue;
            sprite = _ref[sprite_key];
            _fn(sprite);
          }
          async.series(series, function(next, err) {
            callback(null, css);
            if (typeof _this.options.done === 'function') {
              _this.options.done();
            }
          });
        });
      });
    };

    Lemonade.prototype._sprite_key_from_map = function(map) {
      var matches;
      if ((matches = map.match(/sprite:(.+?);/)) !== null) {
        return matches[1];
      } else {
        return void 0;
      }
    };

    Lemonade.prototype._generate_placeholder = function(key, map, png) {
      var sprite, sprite_key, _base, _ref,
        _this = this;
      sprite_key = this._sprite_key_from_map(map);
      sprite = (_ref = (_base = this.sprites)[sprite_key]) != null ? _ref : _base[sprite_key] = new Sprite(map);
      if (png != null) {
        this.series.push(function(callback) {
          return sprite.add(png, callback);
        });
      }
      return "SPRITE_" + key + "_PLACEHOLDER(" + sprite_key + ", " + (png != null ? png : png = '') + ")";
    };

    Lemonade.prototype.image_path = function(png) {
      return this.options.image_path + png + '.png';
    };

    Lemonade.prototype.sprite_url = function(png) {
      return this.options.sprite_url + png + '.png';
    };

    Lemonade.prototype.sprite_path = function(png) {
      return this.options.sprite_path + png + '.png';
    };

    Lemonade.prototype.relative_path = function(file) {
      return file.replace(process.cwd() + '/', '');
    };

    return Lemonade;

  })();

  Sprite = (function() {

    function Sprite(map) {
      var token, _i, _len, _ref;
      this.options = {
        repeat: 'no-repeat'
      };
      _ref = map.split(';').slice(0, -1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        token = _ref[_i];
        token = token.split(':');
        this.options[token[0].trim()] = token[1].trim().toLowerCase();
      }
      this.images = {};
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.png = void 0;
      this._digest = void 0;
      return;
    }

    Sprite.prototype.digest = function() {
      var blob, image, key, _ref;
      if (typeof this._digest !== 'undefined') {
        return this._digest;
      }
      blob = '';
      _ref = this.images;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        image = _ref[key];
        blob += image.toString() + '|';
      }
      return this._digest = require('crypto').createHash('md5').update(blob).digest('hex').substr(-10);
    };

    Sprite.prototype.digest_file = function() {
      if (!this.digest()) {
        void 0;
      }
      return instance.sprite_path(this.options.sprite + '-' + this.digest());
    };

    Sprite.prototype.digest_url = function() {
      if (!this.digest()) {
        void 0;
      }
      return instance.sprite_url(this.options.sprite + '-' + this.digest());
    };

    Sprite.prototype.add = function(file, callback) {
      var image,
        _this = this;
      this._digest = void 0;
      if (typeof this.images[file] !== 'undefined') {
        this.images[file];
        callback(null);
      } else {
        image = this.images[file] = new Image(file, this.x, this.y, function(err) {
          if (err) {
            return callback(err);
          }
          _this.width = Math.max(_this.width, image.width);
          _this.y = _this.height += image.height;
          return callback(null);
        });
      }
    };

    Sprite.prototype.render = function(callback) {
      var key, series, sprite, transparency, _fn, _ref;
      sprite = this;
      sprite.png = gd.createTrueColor(sprite.width, sprite.height);
      transparency = sprite.png.colorAllocateAlpha(0, 0, 0, 127);
      sprite.png.fill(0, 0, transparency);
      sprite.png.colorTransparent(transparency);
      sprite.png.alphaBlending(0);
      sprite.png.saveAlpha(1);
      series = [];
      _ref = sprite.images;
      _fn = function(image) {
        return series.push(function(next) {
          image.open(function() {
            var x, y, _i, _j, _ref1, _ref2, _ref3, _ref4;
            switch (sprite.options.repeat) {
              case 'no-repeat':
                image.png.copy(sprite.png, image.x, image.y, 0, 0, image.width, image.height);
                break;
              case 'repeat-x':
                for (x = _i = 0, _ref1 = sprite.width, _ref2 = image.width; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; x = _i += _ref2) {
                  image.png.copy(sprite.png, x, image.y, 0, 0, image.width, image.height);
                }
                break;
              case 'repeat-y':
                for (y = _j = 0, _ref3 = sprite.height, _ref4 = image.height; 0 <= _ref3 ? _j <= _ref3 : _j >= _ref3; y = _j += _ref4) {
                  image.png.copy(sprite.png, image.x, y, 0, 0, image.width, image.height);
                }
            }
            next();
          });
        });
      };
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        _fn(sprite.images[key]);
      }
      async.series(series, function(next, err) {
        var file, files, pattern, _i, _len;
        if (err) {
          callback(err);
        }
        pattern = sprite.digest_file().replace(/-[\w\d+]+\.png$/, '-*.png');
        files = require('glob').sync(pattern);
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          fs.unlinkSync(file);
        }
        sprite.png.savePng(sprite.digest_file(), 0, function() {
          console.log("Wrote " + (instance.relative_path(sprite.digest_file())) + ".");
          callback(null, sprite.digest_file());
        });
      });
    };

    return Sprite;

  })();

  Image = (function() {

    function Image(file, x, y, callback) {
      var _this = this;
      this.file = file;
      this.x = x;
      this.y = y;
      this.png = void 0;
      this.height = void 0;
      this.width = void 0;
      this.absfile = instance.image_path(this.file);
      this.open(function(err) {
        if (err) {
          return callback(err);
        }
        _this.height = _this.png.height;
        _this.width = _this.png.width;
        return callback(null);
      });
      return;
    }

    Image.prototype.toString = function() {
      return "Image#file=" + this.file + ",x=" + this.x + ",y=" + this.y + ",width=" + this.width + ",height=" + this.height;
    };

    Image.prototype.open = function(callback) {
      var _this = this;
      return gd.openPng(this.absfile, function(err, png) {
        if (err) {
          return callback(err);
        }
        _this.png = png;
        return callback(null);
      });
    };

    Image.prototype.px = function(i) {
      if (i === 0) {
        return 0;
      } else {
        return i + 'px';
      }
    };

    Image.prototype.coords = function() {
      return this.px(this.x * -1) + ' ' + this.px(this.y * -1);
    };

    return Image;

  })();

  module.exports = function(stylus_instance, options) {
    instance = new Lemonade(options);
    if (stylus_instance != null) {
      instance.infect(stylus_instance);
    }
    return instance;
  };

}).call(this);
